{"version":3,"file":"router.bundle.js","sources":["../lib/utilities.js","../lib/path-to-regexp.js","../lib/route.js","../lib/router.js"],"sourcesContent":["/**\n *\n */\nexport function isDifferentDomain(url, hostName) {\n  if (url.href.indexOf(hostName) === -1) {\n    return true;\n  }\n  return false;\n}\n\n/**\n *\n */\nexport function isMailTo(url) {\n  if (url.origin.indexOf('mailto') > -1) {\n    return true;\n  }\n  return false;\n}\n\n/**\n *\n */\nexport function isModifiedClick(event) {\n  return event.metaKey || event.ctrlKey;\n}\n\n/**\n *\n */\nexport function isNotLeftClick(event) {\n  return event.button !== 0;\n}","/**\n * Expose `pathToRegexp`.\n */\nexport {\n  pathToRegexp,\n  parse,\n  compile,\n  tokensToFunction,\n  tokensToRegExp\n};\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\nvar DEFAULT_DELIMITERS = './'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var next = str[index]\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n\n      if (delimiters.indexOf(path[k]) > -1) {\n        prev = path[k]\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var partial = prev !== '' && next !== undefined && next !== prev\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = prev || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value))\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) {\n        // Prepend partial segment prefixes.\n        if (token.partial) path += token.prefix\n\n        continue\n      }\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER)\n  var delimiters = options.delimiters || DEFAULT_DELIMITERS\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = ''\n  var isEndDelimited = false\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n      isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (token.partial) {\n          route += prefix + '(' + capture + ')?'\n        } else {\n          route += '(?:' + prefix + '(' + capture + '))?'\n        }\n      } else {\n        route += prefix + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + delimiter + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","import {pathToRegexp} from './path-to-regexp.js';\n\n\n/**\n *\n */\nexport default class Route {\n  /**\n   *\n   */\n  constructor(pathPattern, callback) {\n    this.path = pathPattern;\n\n    this.callback = callback;\n\n    this._keys = [];\n    this._options = {};\n\n    this.regex = pathToRegexp(\n      this.path,\n      this._keys,\n      this._options\n    );\n  }\n\n  /**\n   * \n   */\n  matches(requestPath) {\n    let match = this.regex.exec(decodeURIComponent(requestPath));\n    if (match) {\n      return true\n    }\n    return false;\n  }\n\n  /**\n   * \n   */\n  parsePath(requestPath) {\n    // In our Router we check if there is a match prior to calling parsePath\n    // However we keep the check in to avoid errors\n    let match = this.regex.exec(decodeURIComponent(requestPath));\n    if (!match) {\n      console.log('[Route] 404 - No route matched path: ', pathname);\n      return false;\n    }\n\n    let parameters = {};\n    for (let i = 0; i < this._keys.length; i++) {\n      let key = this._keys[i];\n      let param = match[i + 1];\n      if (!param) {\n        continue;\n      }\n\n      parameters[key.name] = decodeURIComponent(param);\n      if (key.repeat) {\n        parameters[key.name] = parameters[key.name].split(key.delimiter)\n      }\n    }\n\n    return parameters;\n  }\n}\n","import {\n  isDifferentDomain,\n  isMailTo,\n  isModifiedClick,\n  isNotLeftClick} from './utilities.js';\n\nimport Route from './route.js';\n\n\n/**\n *\n */\nexport default class Router {\n  /**\n   *\n   */\n  constructor() {\n    this._routeMap = new Map();\n\n    // Bind here so that function passed to\n    // add/remove event listener is the same\n    this._onClick = this._onClick.bind(this);\n    this._onPopState = this._onPopState.bind(this);\n  }\n\n  /**\n   *\n   */\n  _addEventListeners() {\n    document.addEventListener('click', this._onClick);\n    window.addEventListener('popstate', this._onPopState);\n  }\n\n  /**\n   *\n   */\n  _removeEventListeners() {\n    document.removeEventListener('click', this._onClick);\n    window.removeEventListener('popstate', this._onPopState);\n  }\n\n  /**\n   *\n   */\n  _onPopState(e) {\n    let url = location;\n    this._handleRoute(url.pathname);\n  }\n\n  /**\n   *\n   */\n  _onClick(e) {\n    // Step 1: Verify click is one we want to potentially intercept\n    if (isNotLeftClick(e)) {\n      return;\n    }\n\n    if(isModifiedClick(e)) {\n      return;\n    }\n\n    // Step 2: Verify click occurred on anchor element or\n    // on element wrapped by anchor element\n    let element = e.target;\n  \n    let anchor;\n    if (e.composedPath) {\n      // If browser supports composedPath use it to crawl\n      // Preferred over parentNode as it works with Shadow DOM\n      // in addition to regular DOM\n      let paths = e.composedPath();\n      for (let i = 0, n = paths.length; i < n; i++) {\n        let item = paths[i];\n        if (item.tagName === 'A') {\n          anchor = item;\n          break;\n        }\n      }\n    } else {\n      // Fallback to legacy parentNode crawl\n      while (element) {\n        if (element.tagName === 'A') {\n          anchor = element;\n          break;\n        }\n        // Update iterator\n        element = element.parentNode;\n      }\n    }\n\n    if (!(anchor)) {\n      // Click did NOT occur on an anchor\n      return;\n    }\n\n    // Step 3: Verify anchor meets criteria\n    if (anchor.hasAttribute('target')) {\n      return;\n    }\n\n    if (anchor.hasAttribute('download')) {\n      return;\n    }\n\n    if (!(anchor.hasAttribute('href'))) {\n      return;\n    }\n\n    // Step 4: Verify anchor HREF meets criteria\n    let pageOrigin = location.origin;\n    let pageHostname = location.hostname;\n\n    let href= anchor.getAttribute('href');\n    let url = new URL(href, pageOrigin); // Normalize href via URL API\n\n    if (isDifferentDomain(url, pageHostname)) {\n      return;\n    }\n\n    if (isMailTo(url)) {\n      return;\n    }\n\n    // We have verified:\n    // * click type\n    // * anchor tag clicked\n    // * anchor tag criteria\n    // * anchor HREF criteria\n    e.preventDefault();\n\n    this._handleRequest(url);\n  }\n\n  /**\n   *\n   */\n  _handleRequest(url) {\n    let requestPath = url.pathname;\n    this._handleRoute(requestPath);\n    this._setPushState(requestPath);\n  }\n\n  /**\n   *\n   */\n  _handleRoute(requestPath) {\n    let route = this._getRoute(requestPath);\n    if (!route) {\n      console.log('[Router] 404 - No route matched path: ', requestPath);\n      return;\n    }\n\n    let ctx = {};\n    // TODO: Verify this is link we have clicked\n    // This looks like it's the current state which is incorrect\n    ctx.url = window.location;\n    ctx.params = route.parsePath(requestPath);\n\n    route.callback.call({}, ctx);\n  }\n\n  /**\n   *\n   */\n  _setPushState(pathname) {\n    let stateObject = {};\n    history.pushState(stateObject, '', pathname);   \n  }\n\n  /**\n   * \n   */\n  _getRoute(requestPath) {\n    let route;\n    for (let [key, value] of this._routeMap) {\n      route = value;\n      if (route.matches(requestPath)) {\n        console.log('[Router] Route matched path: ', requestPath);\n        break;\n      }\n      // Reset route to ensure if for loops never finds\n      // a match route is correctly null\n      route = null;\n    }\n    return route;\n  }\n\n  /* Public API */\n  /**\n   *\n   */\n  enable() {\n    this._addEventListeners();\n\n    let url = location;\n    this._handleRoute(url.pathname);\n  }\n\n  /**\n   *\n   */\n  disable() {\n    this._removeEventListeners();\n  }\n\n  /**\n   *\n   */\n  route(pathPattern, callback) {\n    let route = new Route(pathPattern, callback);\n\n    this._routeMap.set(route.regex, route);\n  }\n}\n"],"names":["isDifferentDomain","url","hostName","href","indexOf","isMailTo","origin","isModifiedClick","event","metaKey","ctrlKey","isNotLeftClick","button","parse","str","options","res","tokens","key","index","path","defaultDelimiter","delimiter","DEFAULT_DELIMITER","delimiters","DEFAULT_DELIMITERS","pathEscaped","PATH_REGEXP","exec","m","escaped","offset","slice","length","prev","next","name","capture","group","modifier","k","push","partial","undefined","repeat","optional","pattern","prefix","escapeGroup","escapeString","substr","replace","flags","sensitive","regexpToRegexp","keys","groups","source","match","i","arrayToRegexp","parts","pathToRegexp","RegExp","join","stringToRegexp","tokensToRegExp","strict","end","endsWith","concat","map","route","isEndDelimited","token","Array","isArray","Route","[object Object]","pathPattern","callback","this","_keys","_options","regex","requestPath","decodeURIComponent","console","log","pathname","parameters","param","split","Router","_routeMap","Map","_onClick","bind","_onPopState","document","addEventListener","window","removeEventListener","e","location","_handleRoute","anchor","element","target","composedPath","paths","n","item","tagName","parentNode","hasAttribute","pageOrigin","pageHostname","hostname","getAttribute","URL","preventDefault","_handleRequest","_setPushState","_getRoute","ctx","params","parsePath","call","stateObject","history","pushState","value","matches","_addEventListeners","_removeEventListeners","set"],"mappings":"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"}